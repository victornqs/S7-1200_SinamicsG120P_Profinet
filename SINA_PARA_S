
//=============================================================================
//SIEMENS AG
//(c)Copyright 2017 All Rights Reserved
//-----------------------------------------------------------------------------
// Library: DriveLib
// Tested with: S7-1516-3 PN/DP V1.8
// Engineering: TIA Portal V14
// Restrictions: -
// Requirements: S7-1200 / S7-1500
// Functionality: read and write one parameter from/to a Sinamics
//
//=============================================================================

// Auftrag "Parameter lesen" bzw. Auftrag "Parameter schreiben" wird nicht mehr ausgeführt
IF NOT #sbBusy THEN
  #sbParaNo := TRUE;
  #syAxisNo := #AxisNo;
END_IF;

// Starten 
IF #Start AND NOT #sbStart AND NOT #sbBusy THEN
  
  #sbReady := False;
  #sbError := False;
  #sbBusy := False;
  
  // Auftrag "Parameter lesen" erkennen
  IF NOT #ReadWrite THEN
    #sbRead := True;
    #sbWrStart := True;
    #sbRdStart := False;
    
    #sbWrite := False;
    #sbWrStart1 := False;
    #sbRdStart1 := False;
    #sbWrStart2 := False;
    #sbRdStart2 := False;
    
    // Referenzauftragsnummer erzeugen
    #siReqRef := #siReqRef + 1;
    
    // bei Überschreitung wieder zurücksetzen und von vorne (Wertebereich von 0-255)
    IF #siReqRef > 255 THEN
      #siReqRef := 0;
    END_IF;
    
    // Auftrag "Parameter schreiben" erkennen
  ELSE
    #sbWrite := True;
    #sbWrStart1 := True;
    #sbRdStart1 := False;
    #sbWrStart2 := False;
    #sbRdStart2 := False;
    
    #sbRead := False;
    #sbWrStart := False;
    #sbRdStart := False;
    
    // Referenzauftragsnummer erzeugen
    #siReqRef := #siReqRef + 1;
    
    // bei Überschreitung wieder zurücksetzen und von vorne (Wertebereich von 0-255)
    IF #siReqRef > 255 THEN
      #siReqRef := 0;
    END_IF;
  END_IF;
  
  // Fehler 4 und 5 wieder zurücknehmen
  IF (#siErrorId = 4) OR (#siErrorId = 5) THEN
    #sbError := False;
    #siErrorId := 0;
  END_IF;
END_IF;

// "Start commando" Flanke merken
#sbStart := #Start;

// Abbrechen
IF NOT #Start THEN
  
  #siErrorCount := 0;
  // Schreib - oder Lesevorgang abbrechen
  #sbRead := False;
  #sbWrStart := False;
  #sbRdStart := False;
  
  #sbWrite := False;
  #sbWrStart1 := False;
  #sbRdStart1 := False;
  #sbWrStart2 := False;
  #sbRdStart2 := False;
  
  // Auftag ist noch beschäftigt => Fehler ausgeben
  IF #sbBusy THEN
    #sbError := True;
    #siErrorId := 4;
    #sbBusy := False;
  END_IF;
END_IF;


// Auftrag "Parameter lesen" wurde ausgelöst
IF #sbParaNo AND #sbRead AND NOT #sbWrite THEN
  
  // Auftrag "Parameter lesen" vorbereiten und abschicken
  IF #sbWrStart THEN
    
    // Ablöschen des Sendepuffers
    // Parameternummer des Parameters 
    #sxReqParaMulti.sxParaAdress.siParaNo := 0;
    
    // Subindex des Parameters
    #sxReqParaMulti.sxParaAdress.siIndex := 0;
    
    // Auftrags-HEADER erstellen
    // Auftragsreferenz
    #sxReqParaMulti.sxHeader.syReqRef := INT_TO_BYTE(#siReqRef);
    
    // Auftragskennung 0x01=Request Parameters
    #sxReqParaMulti.sxHeader.syReqId := B#16#01;
    
    // Achse
    #sxReqParaMulti.sxHeader.syAxisNo := #syAxisNo;
    
    // Anzahl Parameter        
    #sxReqParaMulti.sxHeader.syParaNo := B#16#01;
    
    // Auftrags-PARAMETERADRESSE erstellen
    // Parameternummer des Parameters                                
    #sxReqParaMulti.sxParaAdress.siParaNo := #Parameter;
    
    // Subindex des Parameters
    #sxReqParaMulti.sxParaAdress.siIndex := #Index;
    
    // SCHREIBEN AZYKLISCH
    #piLenTele := #siLenHeader + #siLenParaMulti;
    #WRREC_1(REQ := True,                                // Startimpuls
             ID := #hardwareId,                         // Diagnoseadresse
             INDEX := 47,                                  // Rahmentyp
             LEN := INT_TO_UINT(#piLenTele),             // maximale Länge
             DONE => #sbWrDone,                           // Schreibauftrag beendet
             BUSY => #sbWrBusy,                           // Slave beschäftigt
             ERROR => #sbWrError,                          // Fehler beim Schreiben
             STATUS => #pdStatus,                           // Status[1] = Error => Status[2] Error Decode + Status[3] Error Code
             RECORD := #sxReqParaMulti);                    // Zeiger auf zu schreibenen Datensatzes
    
    // Ausgänge setzen
    #sbBusy := #sbWrBusy;
    #sbDone := #sbWrDone;
    
    // Fehler auswerten
    IF #sbWrError THEN
      
      // Fehlerstatus aus dem Doppelwort filtern und weitergeben                
      #pwWord1 := DWORD_TO_WORD(SHR(IN := (#pdStatus AND DW#16#FFFF00), N := 8));
      
      // Fehlerstatus setzen
      #siErrorId := 3;
      #DiagId := #pwWord1;
      
      //Temporärer Fehler: #pdStatus = 80A7, 80B5, 80C0, 80C1, 80C2, 80C3 oder 80C4 zulassen und nocheinmal versuchen
      IF NOT (#pwWord1 = DW#16#80A7) AND NOT (#pwWord1 = DW#16#80B5) AND NOT (#pwWord1 = DW#16#80C0) AND
        NOT (#pwWord1 = DW#16#80C1) AND NOT (#pwWord1 = DW#16#80C2) AND NOT (#pwWord1 = DW#16#80C3) AND
        NOT (#pwWord1 = DW#16#80C4) THEN
        
        // Wiederholungsauftrag wieder zurücknehmen 
        #sbWrStart := False;
        #sbRdStart := False;
        #sbRead := False;
        
        // Fehler ausgeben 
        #sbError := #sbWrError;
        
      ELSE
        // Fehlerwiederholauftrag ??                   
        IF #siErrorCount = #siMaxErrCount THEN
          
          // Wiederholungsauftrag wieder zurücknehmen
          #sbWrStart := False;
          #sbRdStart := False;
          #sbRead := False;
          
          //Fehlerzähler zurücksetzen
          #siErrorCount := 0;
          
          
          // Fehler ausgeben 
          #sbError := #sbWrError;
          
          // nix tun bis Zähler überläuft
        ELSE
          #siErrorCount := #siErrorCount + 1;
        END_IF;
      END_IF;
      
      // kein Fehler beim SCHEIBEN AZYKLISCH und Auftrag fertig 
    ELSIF NOT #sbWrBusy AND #sbWrDone THEN
      
      // Fehlerkennung zurücknehmen
      IF #siErrorId = 3 THEN
        #siErrorId := 0;
        #sbError := False;
      END_IF;
      
      #DiagId := W#16#00;
      
      // Schreibauftrag fertig melden und Leseantrag anstossen
      #sbWrStart := False;
      #sbRdStart := True;
    END_IF;
  END_IF; // Auftrag "Parameter lesen" vorbereiten und abschicken
  
  // vom Auftrag "Parameter lesen" die Antwort abwarten und dann auswerten
  IF #sbRdStart THEN
    
    // Ablöschen des Empfangspuffers
    #sxRespParaMulti.sxHeader.syReqRef := B#16#00;
    #sxRespParaMulti.sxHeader.syReqId := B#16#00;
    #sxRespParaMulti.sxHeader.syAxisNo := B#16#00;
    #sxRespParaMulti.sxHeader.syParaNo := B#16#00;
    
    FOR #piCount := 1 TO #siLenParaMulti DO
      #sxRespParaMulti.sxData[#piCount] := B#16#00;
    END_FOR;
    
    // LESEN AZYKLISCH
    #piLenTele := #siLenHeader + #siLenParaMulti;
    #RDREC_1(REQ := True,                                // Startimpuls
             ID := #hardwareId,                         // Diagnoseadresse        
             INDEX := 47,                                  // Rahmentyp           
             MLEN := INT_TO_UINT(#piLenTele),             // maximale Länge
             VALID => #pbValidSFB,                         // neuer Datensatz empfangen und gültig   
             BUSY => #sbRdBusy,                           // Slave beschäftigt
             ERROR => #sbRdError,                          // Fehler beim Schreiben
             STATUS => #pdStatus,                           // Status[1] = Error => Status[2] Error Decode + Status[3] Error Code 
             LEN => #piLenSFB,                           // Länge des gelesenen Datensatzes
             RECORD := #sxRespParaMulti);                   // Zeiger auf gelesenen Datensatz
    
    // Ausgänge setzen
    #sbBusy := #sbRdBusy;
    #sbDone := #pbValidSFB;
    
    // Fehler auswerten
    IF #sbRdError THEN
      // Fehlerstatus aus dem Doppelwort filtern und weitergeben                
      #pwWord1 := DWORD_TO_WORD(SHR(IN := (#pdStatus AND DW#16#FFFF00), N := 8));
      
      // Fehlerstatus setzen
      #siErrorId := 3;
      #DiagId := #pwWord1;
      
      //Temporärer Fehler: #pdStatus = 80A7, 80B5, 80C0, 80C1, 80C2, 80C3 oder 80C4 zulassen und nocheinmal versuchen
      IF NOT (#pwWord1 = DW#16#80A7) AND NOT (#pwWord1 = DW#16#80B5) AND NOT (#pwWord1 = DW#16#80C0) AND
        NOT (#pwWord1 = DW#16#80C1) AND NOT (#pwWord1 = DW#16#80C2) AND NOT (#pwWord1 = DW#16#80C3) AND
        NOT (#pwWord1 = DW#16#80C4) THEN
        
        // Wiederholungsauftrag wieder zurücknehmen  
        #sbWrStart := False;
        #sbRdStart := False;
        #sbRead := False;
        
        // Fehler ausgeben 
        #sbError := #sbRdError;
        
      ELSE
        // Fehlerwiederholauftrag ??                   
        IF #siErrorCount = #siMaxErrCount THEN
          
          // Wiederholungsauftrag wieder zurücknehmen
          #sbWrStart := False;
          #sbRdStart := False;
          #sbRead := False;
          
          //Fehlerzähler zurücksetzen
          #siErrorCount := 0;
          
          
          // Fehler ausgeben 
          #sbError := #sbRdError;
          
          // nix tun bis Zähler überläuft
        ELSE
          #siErrorCount := #siErrorCount + 1;
        END_IF;
      END_IF;
      
      // Fehler : die Auftragsreferenz der Antwort übertimmt nicht mit der Auftragsreferenz der Anfrage überein
    ELSIF NOT (#siReqRef = BYTE_TO_INT(#sxRespParaMulti.sxHeader.syReqRef)) AND NOT #sbRdBusy AND #pbValidSFB THEN
      #siErrorId := 1;
      #sbError := True;
      #sbDone := False;
      
      // Wiederholungsauftrag wieder zurücknehmen  
      #sbWrStart := False;
      #sbRdStart := False;
      #sbRead := False;
      
      // Fehler : falsche Auftragskennung zurück erhalten    
    ELSIF NOT (#sxRespParaMulti.sxHeader.syReqId = B#16#81 OR #sxRespParaMulti.sxHeader.syReqId = B#16#01) AND
      NOT #sbRdBusy AND #pbValidSFB THEN
      #siErrorId := 1;
      #sbError := True;
      #sbDone := False;
      
      // Wiederholungsauftrag wieder zurücknehmen  
      #sbWrStart := False;
      #sbRdStart := False;
      #sbRead := False;
      
      // Fehler : die angeforderte Anzahl Parameter entspricht nicht der übermittelten Anzahl Parameter überein
    ELSIF NOT (#sxRespParaMulti.sxHeader.syParaNo = B#16#01) AND NOT #sbRdBusy AND #pbValidSFB THEN
      #siErrorId := 1;
      #sbError := True;
      #sbDone := False;
      
      // Wiederholungsauftrag wieder zurücknehmen  
      #sbWrStart := False;
      #sbRdStart := False;
      #sbRead := False;
      
      // Fehler : die Achse entspricht nicht der übergebenen Achse
    ELSIF NOT (#syAxisNo = #sxRespParaMulti.sxHeader.syAxisNo) AND NOT #sbRdBusy AND #pbValidSFB THEN
      #siErrorId := 1;
      #sbError := True;
      #sbDone := False;
      
      // Wiederholungsauftrag wieder zurücknehmen  
      #sbWrStart := False;
      #sbRdStart := False;
      #sbRead := False;
      
      // kein Fehler beim LESEN AZYKLISCH und Auftrag fertig 
    ELSIF NOT #sbRdBusy AND #pbValidSFB THEN
      
      // die angefragten Parameter auswerten und im Puffer abspeichern
      
      // ermitteltes Format des Parameters abspeichern
      #syFormat := #sxRespParaMulti.sxData[1];
      
      // Format = Error ? = > gesendeter Parameter fehlerhaft
      IF (BYTE_TO_INT(#sxRespParaMulti.sxData[1]) = 68) THEN
        
        // Format = Error, zwei Bytes zu übermittelten Fehlernummer zusammenfassen
        #pwWordHigh := SHL(IN := BYTE_TO_WORD(#sxRespParaMulti.sxData[3]), N := 8);
        #pwWordLow := BYTE_TO_WORD(#sxRespParaMulti.sxData[4]);
        
        #sbError := True;
        
        // ermittelte Fehlernummer im Puffer abspeichern
        #ErrorNo := #pwWordHigh XOR #pwWordLow;
        
        // Die Fehlerhaftigkeit des erkannten Parameter in der Fehlernummer eintragen   
        #swParaError := #swParaError OR W#16#01;
        
        // Format = Byte ? = > gesendeter Parameter ein Byte lang ohne Vorzeichen
      ELSIF (#sxRespParaMulti.sxData[1] = B#16#41) OR (#sxRespParaMulti.sxData[1] = B#16#05) THEN
        
        // ermittelter Parameterwert eintragen (Byte) 
        #ValueRead1 := USINT_TO_REAL(BYTE_TO_USINT(#sxRespParaMulti.sxData[3]));
        #ValueRead2 := 0;
        
        // ermittelte Fehlernummer im Puffer zurücksetzen
        #ErrorNo := W#16#00;
        
        // Die Fehlerhaftigkeit des erkannten Parameter in der Fehlernummer löschen   
        #swParaError := #swParaError AND W#16#FFFE;
        
        // Format = Byte ? = > gesendeter Parameter ein Byte lang mit Vorzeichen
      ELSIF (#sxRespParaMulti.sxData[1] = B#16#02) THEN
        
        // ermittelter Parameterwert eintragen (Byte) 
        #ValueRead1 := SINT_TO_REAL(BYTE_TO_SINT(#sxRespParaMulti.sxData[3]));
        #ValueRead2 := 0;
        
        // ermittelte Fehlernummer im Puffer zurücksetzen
        #ErrorNo := W#16#00;
        
        // Die Fehlerhaftigkeit des erkannten Parameter in der Fehlernummer löschen   
        #swParaError := #swParaError AND W#16#FFFE;
        
        // Format = Word ? = > gesendeter Parameter zwei Bytes lang ohne Vorzeichen
      ELSIF (#sxRespParaMulti.sxData[1] = B#16#42) OR (#sxRespParaMulti.sxData[1] = B#16#06)
        OR (#sxRespParaMulti.sxData[1] = B#16#0A) THEN
        
        // Format = Word, zwei Bytes zu übermitteltem Parameterwert zusammenfassen
        #pwWordHigh := SHL(IN := BYTE_TO_WORD(#sxRespParaMulti.sxData[3]), N := 8);
        #pwWordLow := BYTE_TO_WORD(#sxRespParaMulti.sxData[4]);
        #pwWord1 := #pwWordHigh XOR #pwWordLow;
        
        // ermittelter Parameterwert eintragen (Word)
        #ValueRead1 := UINT_TO_REAL(WORD_TO_UINT(#pwWord1));
        #ValueRead2 := 0;
        
        // ermittelte Fehlernummer im Puffer zurücksetzen
        #ErrorNo := W#16#00;
        
        // Die Fehlerhaftigkeit des erkannten Parameter in der Fehlernummer löschen   
        #swParaError := #swParaError AND W#16#FFFE;
        
        // Format = Word ? = > gesendeter Parameter zwei Bytes lang mit Vorzeichen
      ELSIF (#sxRespParaMulti.sxData[1] = B#16#03) THEN
        
        // Format = Word, zwei Bytes zu übermitteltem Parameterwert zusammenfassen
        #pwWordHigh := SHL(IN := BYTE_TO_WORD(#sxRespParaMulti.sxData[3]), N := 8);
        #pwWordLow := BYTE_TO_WORD(#sxRespParaMulti.sxData[4]);
        #pwWord1 := #pwWordHigh XOR #pwWordLow;
        
        // ermittelter Parameterwert eintragen (Word)
        #ValueRead1 := INT_TO_REAL(WORD_TO_INT(#pwWord1));
        #ValueRead2 := 0;
        
        // ermittelte Fehlernummer im Puffer zurücksetzen
        #ErrorNo := W#16#00;
        
        // Die Fehlerhaftigkeit des erkannten Parameter in der Fehlernummer löschen   
        #swParaError := #swParaError AND W#16#FFFE;
        
        // Format = Double Word ? = > gesendeter Parameter vier Bytes lang ohne Vorzeichen
      ELSIF (#sxRespParaMulti.sxData[1] = B#16#43) OR (#sxRespParaMulti.sxData[1] = B#16#07) OR
        (#sxRespParaMulti.sxData[1] = B#16#0D) THEN
        
        // Format = Double Word, vier Bytes zu übermitteltem Parameterwert zusammenfassen
        #pwWordHigh := SHL(IN := BYTE_TO_WORD(#sxRespParaMulti.sxData[3]), N := 8);
        #pwWordLow := BYTE_TO_WORD(#sxRespParaMulti.sxData[4]);
        #pwWord1 := #pwWordHigh XOR #pwWordLow;
        
        #pwWordHigh := SHL(IN := BYTE_TO_WORD(#sxRespParaMulti.sxData[5]), N := 8);
        #pwWordLow := BYTE_TO_WORD(#sxRespParaMulti.sxData[6]);
        #pwWord2 := #pwWordHigh XOR #pwWordLow;
        
        #pdDWordHigh := SHL(IN := WORD_TO_DWORD(#pwWord1), N := 16);
        #pdDWordLow := WORD_TO_DWORD(#pwWord2);
        
        // ermittelter Parameterwert eintragen (Word)
        #ValueRead1 := 0.0;
        #ValueRead2 := DWORD_TO_DINT(#pdDWordHigh XOR #pdDWordLow);
        
        // ermittelte Fehlernummer im Puffer zurücksetzen
        #ErrorNo := W#16#00;
        
        // Die Fehlerhaftigkeit des erkannten Parameter in der Fehlernummer löschen   
        #swParaError := #swParaError AND W#16#FFFE;
        
        // Format = Double Word ? = > gesendeter Parameter vier Bytes lang mit Vorzeichen
      ELSIF (#sxRespParaMulti.sxData[1] = B#16#04) THEN
        
        // Format = Double Word, vier Bytes zu übermitteltem Parameterwert zusammenfassen
        #pwWordHigh := SHL(IN := BYTE_TO_WORD(#sxRespParaMulti.sxData[3]), N := 8);
        #pwWordLow := BYTE_TO_WORD(#sxRespParaMulti.sxData[4]);
        #pwWord1 := #pwWordHigh XOR #pwWordLow;
        
        #pwWordHigh := SHL(IN := BYTE_TO_WORD(#sxRespParaMulti.sxData[5]), N := 8);
        #pwWordLow := BYTE_TO_WORD(#sxRespParaMulti.sxData[6]);
        #pwWord2 := #pwWordHigh XOR #pwWordLow;
        
        #pdDWordHigh := SHL(IN := WORD_TO_DWORD(#pwWord1), N := 16);
        #pdDWordLow := WORD_TO_DWORD(#pwWord2);
        
        // ermittelter Parameterwert eintragen (Word)
        #ValueRead1 := 0.0;
        #ValueRead2 := DWORD_TO_DINT(#pdDWordHigh XOR #pdDWordLow);
        
        // ermittelte Fehlernummer im Puffer zurücksetzen
        #ErrorNo := W#16#00;
        
        // Die Fehlerhaftigkeit des erkannten Parameter in der Fehlernummer löschen   
        #swParaError := #swParaError AND W#16#FFFE;
        
        // Format = Double Word ? = > gesendeter Parameter vier Bytes lang (FloatingPoint)
      ELSIF (#sxRespParaMulti.sxData[1] = B#16#08) THEN
        
        // Format = Double Word, vier Bytes zu übermitteltem Parameterwert zusammenfassen
        #pwWordHigh := SHL(IN := BYTE_TO_WORD(#sxRespParaMulti.sxData[3]), N := 8);
        #pwWordLow := BYTE_TO_WORD(#sxRespParaMulti.sxData[4]);
        #pwWord1 := #pwWordHigh XOR #pwWordLow;
        
        #pwWordHigh := SHL(IN := BYTE_TO_WORD(#sxRespParaMulti.sxData[5]), N := 8);
        #pwWordLow := BYTE_TO_WORD(#sxRespParaMulti.sxData[6]);
        #pwWord2 := #pwWordHigh XOR #pwWordLow;
        
        #pdDWordHigh := SHL(IN := WORD_TO_DWORD(#pwWord1), N := 16);
        #pdDWordLow := WORD_TO_DWORD(#pwWord2);
        
        // ermittelter Parameterwert eintragen (Word)
        #ValueRead1 := DWORD_TO_REAL(#pdDWordHigh XOR #pdDWordLow);
        #ValueRead2 := 0;
        
        // ermittelte Fehlernummer im Puffer zurücksetzen
        #ErrorNo := W#16#00;
        
        // Die Fehlerhaftigkeit des erkannten Parameter in der Fehlernummer löschen   
        #swParaError := #swParaError AND W#16#FFFE;
        
        // Unbekanter Datentyp
      ELSE
        
        #siErrorId := 5;
        #sbError := True;
        #sbDone := False;
        // Die Fehlerhaftigkeit des erkannten Parameter in der Fehlernummer eintragen   
        #swParaError := #swParaError OR W#16#01;
        
      END_IF;
      
      // Fehlerkennung zurücknehmen
      IF (#siErrorId = 3) OR (#siErrorId = 1) THEN
        #siErrorId := 0;
        #sbError := False;
      END_IF;
      
      #DiagId := W#16#00;
      
      // Auftrag : Parameter lesen ist abgeschlossen
      #sbRdStart := False;
      #sbRead := False;
    END_IF; // kein Fehler beim LESEN AZYKLISCH und Auftrag fertig 
  END_IF; // vom Auftrag "Parameter lesen" die Antwort abwarten und dann auswerten 
END_IF; // Auftrag "Parameter lesen" wurde ausgelöst

// Auftrag "Parameter schreiben" wurde ausgelöst
IF #sbParaNo AND NOT #sbRead AND #sbWrite THEN
  
  // Auftrag "Parameter schreiben" bzw. "ändern" besteht aus zwei Aufträgen
  // 1. Teilauftrag "Parameter lesen"
  // 2. Teilauftrag "Parameter schreiben bzw. ändern"
  
  // 1. Teilauftrag "Parameter lesen" vorbereiten und abschicken
  IF #sbWrStart1 THEN
    
    // Ablöschen des Sendepuffers
    // Parameternummer des Parameters 
    #sxReqParaMulti.sxParaAdress.siParaNo := 0;
    
    // Subindex des Parameters
    #sxReqParaMulti.sxParaAdress.siIndex := 0;
    
    // Auftrags-HEADER erstellen
    // Auftragsreferenz
    #sxReqParaMulti.sxHeader.syReqRef := INT_TO_BYTE(#siReqRef);
    
    // Auftragskennung 0x01=Request Parameters
    #sxReqParaMulti.sxHeader.syReqId := B#16#01;
    
    // Achse
    #sxReqParaMulti.sxHeader.syAxisNo := #syAxisNo;
    
    // Anzahl Parameter        
    #sxReqParaMulti.sxHeader.syParaNo := B#16#01;
    
    // Auftrags-PARAMETERADRESSE erstellen
    // Parameternummer des Parameters                                
    #sxReqParaMulti.sxParaAdress.siParaNo := #Parameter;
    
    // Subindex des Parameters
    #sxReqParaMulti.sxParaAdress.siIndex := #Index;
    
    // SCHREIBEN AZYKLISCH
    #piLenTele := #siLenHeader + #siLenParaMulti;
    #WRREC_1(REQ := True,                                // Startimpuls
             ID := #hardwareId,                         // Diagnoseadresse
             INDEX := 47,                                  // Rahmentyp
             LEN := INT_TO_UINT(#piLenTele),             // maximale Länge
             DONE => #sbWrDone,                           // Schreibauftrag beendet
             BUSY => #sbWrBusy,                           // Slave beschäftigt
             ERROR => #sbWrError,                          // Fehler beim Schreiben
             STATUS => #pdStatus,                           // Status[1] = Error => Status[2] Error Decode + Status[3] Error Code
             RECORD := #sxReqParaMulti);                    // Zeiger auf zu schreibenen Datensatz
    
    // Ausgänge setzen
    #sbBusy := #sbWrBusy;
    #sbDone := #sbWrDone;
    
    // Fehler auswerten
    IF #sbWrError THEN
      
      // Fehlerstatus aus dem Doppelwort filtern und weitergeben                
      #pwWord1 := DWORD_TO_WORD(SHR(IN := (#pdStatus AND DW#16#FFFF00), N := 8));
      
      // Fehlerstatus setzen
      #siErrorId := 3;
      #DiagId := #pwWord1;
      
      //Temporärer Fehler: #pdStatus = 80A7, 80B5, 80C0, 80C1, 80C2, 80C3 oder 80C4 zulassen und nocheinmal versuchen
      IF NOT (#pwWord1 = DW#16#80A7) AND NOT (#pwWord1 = DW#16#80B5) AND NOT (#pwWord1 = DW#16#80C0) AND
        NOT (#pwWord1 = DW#16#80C1) AND NOT (#pwWord1 = DW#16#80C2) AND NOT (#pwWord1 = DW#16#80C3) AND
        NOT (#pwWord1 = DW#16#80C4) THEN
        
        // Wiederholungsauftrag wieder zurücknehmen
        #sbWrStart1 := False;
        #sbRdStart1 := False;
        #sbWrite := False;
        
        // Fehler ausgeben 
        #sbError := #sbWrError;
        
      ELSE
        // Fehlerwiederholauftrag ??                   
        IF #siErrorCount = #siMaxErrCount THEN
          
          // Wiederholungsauftrag wieder zurücknehmen
          #sbWrStart1 := False;
          #sbRdStart1 := False;
          #sbWrite := False;
          
          //Fehlerzähler zurücksetzen
          #siErrorCount := 0;
          
          
          // Fehler ausgeben 
          #sbError := #sbWrError;
          // nix tun bis Zähler überläuft
        ELSE
          #siErrorCount := #siErrorCount + 1;
        END_IF;
      END_IF;
      
      // kein Fehler beim SCHEIBEN AZYKLISCH und Auftrag fertig 
    ELSIF NOT #sbWrBusy AND #sbWrDone THEN
      
      // Fehlerkennung zurücknehmen
      IF (#siErrorId = 3) THEN
        #siErrorId := 0;
        #sbError := False;
      END_IF;
      
      #DiagId := W#16#00;
      
      // Schreibauftrag fertig melden und Leseantrag anstossen
      #sbWrStart1 := False;
      #sbRdStart1 := True;
    END_IF;
  END_IF; // 1. Teilauftrag "Parameter lesen" vorbereiten und abschicken
  
  // vom 1. Teilauftrag "Parameter lesen" die Antwort abwarten und dann auswerten
  IF #sbRdStart1 THEN
    
    // Ablöschen des Empfangspuffers
    #sxRespParaMulti.sxHeader.syReqRef := B#16#00;
    #sxRespParaMulti.sxHeader.syReqId := B#16#00;
    #sxRespParaMulti.sxHeader.syAxisNo := B#16#00;
    #sxRespParaMulti.sxHeader.syParaNo := B#16#00;
    
    FOR #piCount := 1 TO #siLenParaMulti DO
      #sxRespParaMulti.sxData[#piCount] := B#16#00;
    END_FOR;
    
    // LESEN AZYKLISCH
    #piLenTele := #siLenHeader + #siLenParaMulti;
    #RDREC_1(REQ := True,                                // Startimpuls
             ID := #hardwareId,                         // Diagnoseadresse        
             INDEX := 47,                                  // Rahmentyp           
             MLEN := INT_TO_UINT(#piLenTele),             // maximale Länge
             VALID => #pbValidSFB,                         // neuer Datensatz empfangen und gültig      
             BUSY => #sbRdBusy,                           // Slave beschäftigt
             ERROR => #sbRdError,                          // Fehler beim Schreiben
             STATUS => #pdStatus,                           // Status[1] = Error => Status[2] Error Decode + Status[3] Error Code 
             LEN => #piLenSFB,                           // Länge des gelesenen Datensatzes
             RECORD := #sxRespParaMulti);                   // Zeiger auf gelesenen Datensatz
    
    // Ausgänge setzen
    #sbBusy := #sbRdBusy;
    #sbDone := #pbValidSFB;
    
    // Fehler auswerten
    IF #sbRdError THEN
      // Fehlerstatus aus dem Doppelwort filtern und weitergeben                
      #pwWord1 := DWORD_TO_WORD(SHR(IN := (#pdStatus AND DW#16#FFFF00), N := 8));
      
      // Fehlerstatus setzen
      #siErrorId := 3;
      #DiagId := #pwWord1;
      
      //Temporärer Fehler: #pdStatus = 80A7, 80B5, 80C0, 80C1, 80C2, 80C3 oder 80C4 zulassen und nocheinmal versuchen
      IF NOT (#pwWord1 = DW#16#80A7) AND NOT (#pwWord1 = DW#16#80B5) AND NOT (#pwWord1 = DW#16#80C0) AND
        NOT (#pwWord1 = DW#16#80C1) AND NOT (#pwWord1 = DW#16#80C2) AND NOT (#pwWord1 = DW#16#80C3) AND
        NOT (#pwWord1 = DW#16#80C4) THEN
        
        // Wiederholungsauftrag wieder zurücknehmen
        #sbWrStart1 := False;
        #sbRdStart1 := False;
        #sbWrite := False;
        
        // Fehler ausgeben 
        #sbError := #sbRdError;
        
      ELSE
        // Fehlerwiederholauftrag ??                   
        IF #siErrorCount = #siMaxErrCount THEN
          
          // Wiederholungsauftrag wieder zurücknehmen
          #sbWrStart1 := False;
          #sbRdStart1 := False;
          #sbWrite := False;
          
          //Fehlerzähler zurücksetzen
          #siErrorCount := 0;
          
          
          // Fehler ausgeben 
          #sbError := #sbRdError;
          
          // nix tun bis Zähler überläuft
        ELSE
          #siErrorCount := #siErrorCount + 1;
        END_IF;
      END_IF;
      
      // Fehler : die Auftragsreferenz der Antwort übertimmt nicht mit der Auftragsreferenz der Anfrage überein
    ELSIF NOT (#siReqRef = BYTE_TO_INT(#sxRespParaMulti.sxHeader.syReqRef)) AND NOT #sbRdBusy AND #pbValidSFB THEN
      #siErrorId := 1;
      #sbError := True;
      #sbDone := False;
      
      // Wiederholungsauftrag wieder zurücknehmen
      #sbWrStart1 := False;
      #sbRdStart1 := False;
      #sbWrite := False;
      
      // Fehler : falsche Auftragskennung zurück erhalten    
    ELSIF NOT (#sxRespParaMulti.sxHeader.syReqId = B#16#81 OR #sxRespParaMulti.sxHeader.syReqId = B#16#01) AND
      NOT #sbRdBusy AND #pbValidSFB THEN
      #siErrorId := 1;
      #sbError := True;
      #sbDone := False;
      
      // Wiederholungsauftrag wieder zurücknehmen
      #sbWrStart1 := False;
      #sbRdStart1 := False;
      #sbWrite := False;
      
      // Fehler : die angeforderte Anzahl Parameter entspricht nicht der übermittelten Anzahl Parameter überein
    ELSIF NOT (#sxRespParaMulti.sxHeader.syParaNo = B#16#01) AND NOT #sbRdBusy AND #pbValidSFB THEN
      #siErrorId := 1;
      #sbError := True;
      #sbDone := False;
      
      // Wiederholungsauftrag wieder zurücknehmen
      #sbWrStart1 := False;
      #sbRdStart1 := False;
      #sbWrite := False;
      
      // Fehler : die Achse entspricht nicht der übergebenen Achse
    ELSIF NOT (#syAxisNo = #sxRespParaMulti.sxHeader.syAxisNo) AND NOT #sbRdBusy AND #pbValidSFB THEN
      #siErrorId := 1;
      #sbError := True;
      #sbDone := False;
      
      // Wiederholungsauftrag wieder zurücknehmen
      #sbWrStart1 := False;
      #sbRdStart1 := False;
      #sbWrite := False;
      
      // kein Fehler beim LESEN AZYKLISCH und Auftrag fertig 
    ELSIF NOT #sbRdBusy AND #pbValidSFB THEN
      
      // die angefragten Parameter auswerten und im Puffer abspeichern
      // ermitteltes Format des Parameters abspeichern
      #syFormat := #sxRespParaMulti.sxData[1];
      
      // Format = Error ? = > gesendeter Parameter fehlerhaft
      IF (BYTE_TO_INT(#sxRespParaMulti.sxData[1]) = 68) THEN
        
        // Format = Error, zwei Bytes zu übermittelten Fehlernummer zusammenfassen
        #pwWordHigh := SHL(IN := BYTE_TO_WORD(#sxRespParaMulti.sxData[3]), N := 8);
        #pwWordLow := BYTE_TO_WORD(#sxRespParaMulti.sxData[4]);
            
        #sbError := True;
            
        // ermittelte Fehlernummer im Puffer abspeichern
        #ErrorNo := #pwWordHigh XOR #pwWordLow;
        
        // Die Fehlerhaftigkeit des erkannten Parameter in der Fehlernummer eintragen   
        #swParaError := #swParaError OR W#16#01;
        
        // Format = Byte ? = > gesendeter Parameter ein Byte lang
      ELSIF (#sxRespParaMulti.sxData[1] = B#16#41) OR
        (#sxRespParaMulti.sxData[1] = B#16#02) OR (#sxRespParaMulti.sxData[1] = B#16#05) THEN
        
        // ermittelte Fehlernummer im Puffer zurücksetzen
        #ErrorNo := W#16#00;
        
        // Die Fehlerhaftigkeit des erkannten Parameter in der Fehlernummer löschen   
        #swParaError := #swParaError AND W#16#FFFE;
        
        // Format = Word ? = > gesendeter Parameter zwei Bytes lang
      ELSIF (#sxRespParaMulti.sxData[1] = B#16#42) OR (#sxRespParaMulti.sxData[1] = B#16#03)
        OR (#sxRespParaMulti.sxData[1] = B#16#06) OR (#sxRespParaMulti.sxData[1] = B#16#0A) THEN
        
        // ermittelte Fehlernummer im Puffer zurücksetzen
        #ErrorNo := W#16#00;
        
        // Die Fehlerhaftigkeit des erkannten Parameter in der Fehlernummer löschen   
        #swParaError := #swParaError AND W#16#FFFE;
        
        
        // Format = Double Word ? = > gesendeter Parameter vier Bytes lang
      ELSIF (#sxRespParaMulti.sxData[1] = B#16#43) OR (#sxRespParaMulti.sxData[1] = B#16#04) OR
        (#sxRespParaMulti.sxData[1] = B#16#07) OR (#sxRespParaMulti.sxData[1] = B#16#08) OR
        (#sxRespParaMulti.sxData[1] = B#16#0D) THEN
        
        // ermittelte Fehlernummer im Puffer zurücksetzen
        #ErrorNo := W#16#00;
        
        // Die Fehlerhaftigkeit des erkannten Parameter in der Fehlernummer löschen   
        #swParaError := #swParaError AND W#16#FFFE;
        
        // Unbekanter Datentyp
      ELSE
        
        #siErrorId := 5;
        #sbError := True;
        #sbDone := False;
        // Die Fehlerhaftigkeit des erkannten Parameter in der Fehlernummer eintragen   
        #swParaError := #swParaError OR W#16#01;
        
      END_IF;
      
      // Fehlerkennung zurücknehmen
      IF (#siErrorId = 3) OR (#siErrorId = 1) THEN
        #siErrorId := 0;
        #sbError := False;
      END_IF;
      
      #DiagId := W#16#00;
      
      // 1. Teilauftrag "Parameter lesen" ist abgeschlossen
      #sbRdStart1 := False;
      
      // einer der gesendeten Parameter ist fehlerhaft => Abbruch, kein "Parameter schreiben" erforderlich
      IF (#swParaError = W#16#00) THEN
        #sbWrStart2 := True;
      ELSE
        #sbWrStart2 := False;
      END_IF;
    END_IF; // kein Fehler beim LESEN AZYKLISCH und Auftrag fertig 
  END_IF; // vom 1. Teilauftrag "Parameter lesen" die Antwort abwarten und dann auswerten 
  
  // 2. Teilauftrag "Parameter schreiben bzw. ändern" vorbereiten und abschicken
  IF #sbWrStart2 THEN
    
    // Ablöschen des Sendepuffers            
    FOR #piCount := 1 TO #siLenChaPara DO
      // Parameteradresse und Parameterwert des Parameters 
      #sxChaParaMulti.sxData[#piCount] := B#16#00;
    END_FOR;
    
    // Auftrags-HEADER erstellen
    // Auftragsreferenz
    #sxChaParaMulti.sxHeader.syReqRef := INT_TO_BYTE(#siReqRef);
    
    // Auftragskennung 0x01=Request Parameters | 0x02=Change Parameters
    #sxChaParaMulti.sxHeader.syReqId := B#16#02;
    
    // Achse
    #sxChaParaMulti.sxHeader.syAxisNo := #syAxisNo;
    
    // Anzahl Parameter        
    #sxChaParaMulti.sxHeader.syParaNo := B#16#01;
    
    // Auftrags-PARAMETERADRESSE erstellen                
    // Attribute of parameters (0x10=Value, 0x30=Text)
    #sxChaParaMulti.sxData[1] := B#16#10;
    
    // No. of elements (DEC: for single elements=1) 
    #sxChaParaMulti.sxData[2] := B#16#01;
    
    // Parameternummer des Parameters                                
    #sxChaParaMulti.sxData[4] := INT_TO_BYTE(#Parameter);
    #sxChaParaMulti.sxData[3] := WORD_TO_BYTE(SHR(IN := INT_TO_WORD(#Parameter), N := 8));
    
    // Subindex des Parameters
    #sxChaParaMulti.sxData[6] := INT_TO_BYTE(#Index);
    #sxChaParaMulti.sxData[5] := WORD_TO_BYTE(SHR(IN := INT_TO_WORD(#Index), N := 8));
    
    // Auftrags-PARAMETERVALUE erstellen    
    // Format (BYTE, WORD, DWORD des Parameterwert übergeben
    #sxChaParaMulti.sxData[7] := #syFormat;
    
    // Number of value
    #sxChaParaMulti.sxData[8] := B#16#01;
    
    // Value of parameter in Bytes
    IF (#syFormat = B#16#41) OR
      (#syFormat = B#16#02) OR (#syFormat = B#16#05) THEN
      
      #sxChaParaMulti.sxData[9] := WORD_TO_BYTE(DWORD_TO_WORD(DINT_TO_DWORD(REAL_TO_DINT(#ValueWrite1))));
      #sxChaParaMulti.sxData[10] := 16#00;  //WORD_TO_BYTE(DWORD_TO_WORD(SHR(IN := DINT_TO_DWORD(REAL_TO_DINT(#ValueWrite1)), N := 8)));
      
      // Value of parameter in Word
    ELSIF (#syFormat = B#16#42) OR (#syFormat = B#16#03) OR
      (#syFormat = B#16#06) OR (#syFormat = B#16#0A) THEN
      
      #sxChaParaMulti.sxData[10] := WORD_TO_BYTE(DWORD_TO_WORD(DINT_TO_DWORD(REAL_TO_DINT(#ValueWrite1))));
      #sxChaParaMulti.sxData[9] := WORD_TO_BYTE(DWORD_TO_WORD(SHR(IN := DINT_TO_DWORD(REAL_TO_DINT(#ValueWrite1)), N := 8)));
      
      // Value of parameter in DWord    
    ELSIF (#syFormat = B#16#43) OR (#syFormat = B#16#04) OR
      (#syFormat = B#16#07) OR (#syFormat = B#16#0D) THEN
      
      #sxChaParaMulti.sxData[12] := WORD_TO_BYTE(DWORD_TO_WORD(DINT_TO_DWORD(#ValueWrite2)));
      #sxChaParaMulti.sxData[11] := WORD_TO_BYTE(DWORD_TO_WORD(SHR(IN := DINT_TO_DWORD(#ValueWrite2), N := 8)));
      #sxChaParaMulti.sxData[10] := WORD_TO_BYTE(DWORD_TO_WORD(SHR(IN := DINT_TO_DWORD(#ValueWrite2), N := 16)));
      #sxChaParaMulti.sxData[9] := WORD_TO_BYTE(DWORD_TO_WORD(SHR(IN := DINT_TO_DWORD(#ValueWrite2), N := 24)));
      
      
      // Value of parameter in DWord (FloatingPoint)   
    ELSIF (#syFormat = B#16#08) THEN
      
      #sxChaParaMulti.sxData[12] := WORD_TO_BYTE(DWORD_TO_WORD(REAL_TO_DWORD(#ValueWrite1)));
      #sxChaParaMulti.sxData[11] := WORD_TO_BYTE(DWORD_TO_WORD(SHR(IN := REAL_TO_DWORD(#ValueWrite1), N := 8)));
      #sxChaParaMulti.sxData[10] := WORD_TO_BYTE(DWORD_TO_WORD(SHR(IN := REAL_TO_DWORD(#ValueWrite1), N := 16)));
      #sxChaParaMulti.sxData[9] := WORD_TO_BYTE(DWORD_TO_WORD(SHR(IN := REAL_TO_DWORD(#ValueWrite1), N := 24)));
      
    END_IF;
    
    // SCHREIBEN AZYKLISCH
    #piLenTele := #siLenHeader + #siLenChaPara;
    #WRREC_1(REQ := True,                                // Startimpuls
             ID := #hardwareId,                         // Diagnoseadresse
             INDEX := 47,                                  // Rahmentyp
             LEN := INT_TO_UINT(#piLenTele),             // maximale Länge
             DONE => #sbWrDone,                           // Schreibauftrag beendet
             BUSY => #sbWrBusy,                           // Slave beschäftigt
             ERROR => #sbWrError,                          // Fehler beim Schreiben
             STATUS => #pdStatus,                           // Status[1] = Error => Status[2] Error Decode + Status[3] Error Code
             RECORD := #sxChaParaMulti);                    // Zeiger auf zu schreibenen Datensatzes
    
    // Ausgänge setzen
    #sbBusy := #sbWrBusy;
    #sbDone := #sbWrDone;
    
    // Fehler auswerten
    IF #sbWrError THEN
      // Fehlerstatus aus dem Doppelwort filtern und weitergeben                
      #pwWord1 := DWORD_TO_WORD(SHR(IN := (#pdStatus AND DW#16#FFFF00), N := 8));
      
      // Fehlerstatus setzen
      #siErrorId := 3;
      #sbError := False;
      #DiagId := #pwWord1;
      
      //Temporärer Fehler: #pdStatus = 80A7, 80B5, 80C0, 80C1, 80C2, 80C3 oder 80C4 zulassen und nocheinmal versuchen
      IF NOT (#pwWord1 = DW#16#80A7) AND NOT (#pwWord1 = DW#16#80B5) AND NOT (#pwWord1 = DW#16#80C0) AND
        NOT (#pwWord1 = DW#16#80C1) AND NOT (#pwWord1 = DW#16#80C2) AND NOT (#pwWord1 = DW#16#80C3) AND
        NOT (#pwWord1 = DW#16#80C4) THEN
        
        // Wiederholungsauftrag wieder zurücknehmen
        #sbWrStart2 := False;
        #sbRdStart2 := False;
        #sbWrite := False;
        
        // Fehler ausgeben 
        #sbError := #sbWrError;
        
      ELSE
        // Fehlerwiederholauftrag ??                   
        IF #siErrorCount = #siMaxErrCount THEN
          
          // Wiederholungsauftrag wieder zurücknehmen
          #sbWrStart2 := False;
          #sbRdStart2 := False;
          #sbWrite := False;
          
          //Fehlerzähler zurücksetzen
          #siErrorCount := 0;
          
          
          // Fehler ausgeben 
          #sbError := #sbWrError;
          
          // nix tun bis Zähler überläuft
        ELSE
          #siErrorCount := #siErrorCount + 1;
        END_IF;
      END_IF;
      
      // kein Fehler beim SCHEIBEN AZYKLISCH und Auftrag fertig 
    ELSIF NOT #sbWrBusy AND #sbWrDone THEN
      // Fehlerkennung zurücknehmen
      #DiagId := W#16#00;
      
      // Schreibauftrag fertig melden und Leseantrag anstossen
      #sbWrStart2 := False;
      #sbRdStart2 := True;
    END_IF;
  END_IF; // 2. Teilauftrag "Parameter schreiben bzw. ändern" vorbereiten und abschicken
  
  // vom 2. Teilauftrag "Parameter schreiben bzw. ändern" die Antwort abwarten und dann auswerten
  IF #sbRdStart2 THEN
    
    // Ablöschen des Empfangspuffers
    #sxRespParaMulti.sxHeader.syReqRef := B#16#00;
    #sxRespParaMulti.sxHeader.syReqId := B#16#00;
    #sxRespParaMulti.sxHeader.syAxisNo := B#16#00;
    #sxRespParaMulti.sxHeader.syParaNo := B#16#00;
    
    FOR #piCount := 1 TO #siLenParaMulti DO
      #sxRespParaMulti.sxData[#piCount] := B#16#00;
    END_FOR;
    
    // LESEN AZYKLISCH
    #piLenTele := #siLenHeader + #siLenParaMulti;
    #RDREC_1(REQ := True,                                // Startimpuls
             ID := #hardwareId,                         // Diagnoseadresse        
             INDEX := 47,                                  // Rahmentyp           
             MLEN := INT_TO_UINT(#piLenTele),             // maximale Länge
             VALID => #pbValidSFB,                         // neuer Datensatz empfangen und gültig   
             BUSY => #sbRdBusy,                           // Slave beschäftigt
             ERROR => #sbRdError,                          // Fehler beim Schreiben
             STATUS => #pdStatus,                           // Status[1] = Error => Status[2] Error Decode + Status[3] Error Code 
             LEN => #piLenSFB,                           // Länge des gelesenen Datensatzes
             RECORD := #sxRespParaMulti);                   // Zeiger auf gelesenen Datensatz
    
    // Ausgänge setzen
    #sbBusy := #sbRdBusy;
    #sbDone := #pbValidSFB;
    
    // Fehler auswerten
    IF #sbRdError THEN
      // Fehlerstatus aus dem Doppelwort filtern und weitergeben                
      #pwWord1 := DWORD_TO_WORD(SHR(IN := (#pdStatus AND DW#16#FFFF00), N := 8));
      
      // Fehlerstatus setzen
      #siErrorId := 3;
      #DiagId := #pwWord1;
      
      //Temporärer Fehler: #pdStatus = 80A7, 80B5, 80C0, 80C1, 80C2, 80C3 oder 80C4 zulassen und nocheinmal versuchen
      IF NOT (#pwWord1 = DW#16#80A7) AND NOT (#pwWord1 = DW#16#80B5) AND NOT (#pwWord1 = DW#16#80C0) AND
        NOT (#pwWord1 = DW#16#80C1) AND NOT (#pwWord1 = DW#16#80C2) AND NOT (#pwWord1 = DW#16#80C3) AND
        NOT (#pwWord1 = DW#16#80C4) THEN
        
        // Wiederholungsauftrag wieder zurücknehmen
        #sbWrStart2 := False;
        #sbRdStart2 := False;
        #sbWrite := False;
        
        // Fehler ausgeben 
        #sbError := #sbRdError;
        
      ELSE
        // Fehlerwiederholauftrag ??                   
        IF #siErrorCount = #siMaxErrCount THEN
          
          // Wiederholungsauftrag wieder zurücknehmen
          #sbWrStart2 := False;
          #sbRdStart2 := False;
          #sbWrite := False;
          
          //Fehlerzähler zurücksetzen
          #siErrorCount := 0;
          
          
          // Fehler ausgeben 
          #sbError := #sbRdError;
          
          // nix tun bis Zähler überläuft
        ELSE
          #siErrorCount := #siErrorCount + 1;
        END_IF;
      END_IF;
      
      // Fehler : die Auftragsreferenz der Antwort übertimmt nicht mit der Auftragsreferenz der Anfrage überein
    ELSIF NOT (#siReqRef = BYTE_TO_INT(#sxRespParaMulti.sxHeader.syReqRef)) AND NOT #sbRdBusy AND #pbValidSFB THEN
      #siErrorId := 1;
      #sbError := True;
      #sbDone := False;
      
      // Wiederholungsauftrag wieder zurücknehmen
      #sbWrStart2 := False;
      #sbRdStart2 := False;
      #sbWrite := False;
      
      // Fehler : falsche Auftragskennung zurück erhalten    
    ELSIF NOT (#sxRespParaMulti.sxHeader.syReqId = B#16#82 OR #sxRespParaMulti.sxHeader.syReqId = B#16#02) AND
      NOT #sbRdBusy AND #pbValidSFB THEN
      #siErrorId := 1;
      #sbError := True;
      #sbDone := False;
      
      // Wiederholungsauftrag wieder zurücknehmen
      #sbWrStart2 := False;
      #sbRdStart2 := False;
      #sbWrite := False;
      
      // Fehler : die angeforderte Anzahl Parameter entspricht nicht der übermittelten Anzahl Parameter überein
    ELSIF NOT (#sxRespParaMulti.sxHeader.syParaNo = B#16#01) AND NOT #sbRdBusy AND #pbValidSFB THEN
      #siErrorId := 1;
      #sbError := True;
      #sbDone := False;
      
      // Wiederholungsauftrag wieder zurücknehmen
      #sbWrStart2 := False;
      #sbRdStart2 := False;
      #sbWrite := False;
      
      // Fehler : die Achse entspricht nicht der übergebenen Achse
    ELSIF NOT (#syAxisNo = #sxRespParaMulti.sxHeader.syAxisNo) AND NOT #sbRdBusy AND #pbValidSFB THEN
      #siErrorId := 1;
      #sbError := True;
      #sbDone := False;
      
      // Wiederholungsauftrag wieder zurücknehmen
      #sbWrStart2 := False;
      #sbRdStart2 := False;
      #sbWrite := False;
      
      // kein Fehler beim LESEN AZYKLISCH und Auftrag fertig 
    ELSIF NOT #sbRdBusy AND #pbValidSFB THEN
      
      // 2. Teilauftrag "Parameter schreiben bzw. ändern" negative Rückmeldung erhalten 
      IF #sxRespParaMulti.sxHeader.syReqId = B#16#82 THEN
        
        // die angefragten Parameter auswerten und im Puffer abspeichern
        // Format des Parameters auswerten, bei Format = Error Fehler auswerten 
        IF (BYTE_TO_INT(#sxRespParaMulti.sxData[1]) = 68) THEN
          
          // Fehlerwert ermitteln und abspeichern 
          // Format = Word, zwei Bytes zu übermitteltem Parameterwert zusammenfassen
          #pwWordHigh := SHL(IN := BYTE_TO_WORD(#sxRespParaMulti.sxData[3]), N := 8);
          #pwWordLow := BYTE_TO_WORD(#sxRespParaMulti.sxData[4]);
          #pwWord1 := #pwWordHigh XOR #pwWordLow;
            
          #sbError := True;
            
          // ermittelte Fehlernummer im Puffer zurücksetzen
          #ErrorNo := W#16#00;
          
          #ErrorNo := #pwWord1;
          
          // Die Fehlerhaftigkeit des erkannten Parameter in der Fehlernummer eintragen   
          #swParaError := #swParaError OR W#16#01;
          
        ELSE
          
          // Die Fehlerhaftigkeit des erkannten Parameter in der Fehlernummer löschen   
          #swParaError := #swParaError AND W#16#FFFE;
          
          // ermittelte Fehlernummer im Puffer zurücksetzen
          #ErrorNo := W#16#00;
        END_IF;
      END_IF; // 2. Teilauftrag "Parameter schreiben bzw. ändern" negative Rückmeldung erhalten
      
      // Fehlerkennung zurücknehmen
      IF (#siErrorId = 3) OR (#siErrorId = 1) THEN
        #siErrorId := 0;
        #sbError := False;
      END_IF;
      
      #DiagId := W#16#00;
      
      // 2. Teilauftrag "Parameter schreiben bzw. ändern" ist abgeschlossen
      #sbRdStart2 := False;
      #sbWrite := False;
      
    END_IF; // kein Fehler beim LESEN AZYKLISCH und Auftrag fertig 
  END_IF; // vom 2. Teilauftrag "Parameter schreiben bzw. ändern" die Antwort abwarten und dann auswerten 
END_IF; // Auftrag "Parameter schreiben" wurde ausgelöst

#pdDWordHigh := SHL(IN := INT_TO_DWORD(#siErrorId), N := 16);
#pdDWordLow := WORD_TO_DWORD(#swParaError);

// ermittelter Parameterwert eintragen (Word)
#ErrorId := #pdDWordHigh XOR #pdDWordLow;

// Initialisierung von Ausgängen
#Busy := #sbBusy;
#Error := #sbError;
#Format := #syFormat;
// Änderung wegen verhalten von Ready  
#Done := #sbDone;
// Prüfen, ob Auftrag abgeschlossen ist
IF ((#Error OR #Done) AND NOT #sbReady) THEN
  #Ready := True;
  #sbReady := True;
ELSE
  #Ready := False;
END_IF;

